#!/usr/bin/env python
"""
resync: The ResourceSync command line client

Copyright 2012,2013 Simeon Warner

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License
"""

import sys

if (sys.version_info < (2, 7)):
    import optparse
else:
    import argparse

from resync import __version__
from resync.client import Client, ClientFatalError
from resync.client_utils import init_logging, count_true_args, parse_links, parse_capabilities, parse_capability_lists

DEFAULT_LOGFILE = 'resync-client.log'


def main():

    if (sys.version_info < (2, 6)):
        sys.exit("This program requires python version 2.6 or later")

    if (sys.version_info >= (2, 7)):

        p = argparse.ArgumentParser(description='Command-line client for implementing the ResourceSync web synchronization framework.')

        # Options that apply to multiple modes
        p.add_argument('--checksum', action='store_true',
               help="use md5 checksum in addition to last modification time and size "
                "(same as --hash=md5)")
        p.add_argument('--eval', '-e', action='store_true',
               help="Output evaluation of source/client synchronization performance... "
                "be warned, this is very verbose")
        p.add_argument('--hash', type=str, action='append',
               help="Use specified hash types in addition to last modification time "
                "and size (repeatable, may include `md5`, `sha-1` and `sha-256`)")
        p.add_argument('--ignore-failures', action='store_true',
               help="Continue past download failures")
        p.add_argument('--logger', '-l', action='store_true',
               help="Create detailed log of client actions (will write "
                "to %s unless specified with --logfile" %
                DEFAULT_LOGFILE)
        p.add_argument('--logfile', type=str, action='store',
               help="Create detailed log of client actions")
        # These likely only useful for experimentation
        p.add_argument('--max-sitemap-entries', type=int, action='store',
               help="Override default size limits")
        p.add_argument('--multifile', '-m', action='store_true',
               help="Disable reading and output of sitemapindex for multifile sitemap")
        # Want these to show at the end
        p.add_argument('--verbose', '-v', action='store_true',
               help="Verbose, show additional informational messages")

        subparsers = p.add_subparsers(metavar='COMMAND', help='For usage: "resync COMMAND --help".', description='The following commands support each side of the framework, and each requires additional positional arguments.')
        
        loc = subparsers.add_parser('generate',
            help='Generate ResourceSync documents and write them to local disk.')
        loc_mode = loc.add_mutually_exclusive_group()

        loc_mode.add_argument('--resourcelist', '--resource-list', '-r', action='store_true',
               help="Write a resource list based on files on disk using uri=path mappings "
                "in reverse to calculate URIs from the local paths. Scans local disk "
                "based either on explicit --paths setting, else starting from all local "
                "paths specified in the mappings. Writes to STDOUT by default, override "
                "with --outfile")
        loc_mode.add_argument('--changelist', '--change-list', '-c', action='store_true',
               help="Write a change list based on comparison of a reference sitemap "
                "(specify file with --reference) and either files on disk (using "
                "the mapping provided) or a second sitemap (specify file with "
                "--newreference). Otherwise follows --resourcelist options. Also accepts "
                "the --empty option (with no mapping) to write and empty changelist.")
        loc_mode.add_argument('--capabilitylist', '--capability-list', type=str, action='store',
               help="Write a capability list based on the set of capabilities and "
                "URIs supplied in cap_name=URI,cap_name=URI format. Otherwise "
                "follows --resourcelist options.")
        loc_mode.add_argument('--sourcedescription', '--source-description', type=str, action='store',
               help="Write a Source Description document based on the set of capability "
                "list URIs supplied as a comma separated list. Otherwise "
                "follows --resourcelist options.")
        loc_mode.add_argument('--resourcedump', '--resource-dump', '-d', action='store_true',
               help="Write a Resource Dump. Specify output file with --outfile and use other "
                "options as for --resourcelist")
        loc_mode.add_argument('--changedump', '--change-dump', action='store_true',
               help="Write a Resource Dump. Specify output file with --outfile and use other "
                "options as for --changelist")

        loc.add_argument('--warc', action='store_true',
               help="Write dumps in WARC format (instead of ZIP+Sitemap default)")
        loc.add_argument('--empty', action='store_true',
               help="Combine with --changelist to write and empty changelist, perhaps with links")
        loc.add_argument('--paths', type=str, action='store',
               help="Explicit set of paths for disk scan --resourceslist or --changelist "
                "generation")
        loc.add_argument('--exclude', type=str, action='append',
               help="Exclude resources with URI or filename matching the python regex "
                "supplied (see: <https://docs.python.org/2/howto/regex.html> for regex "
                "information, repeat option for multiple excludes)")
        loc.add_argument('--link', type=str, action='append',
               help="Add discovery links to the output sitemap, "
                "format: rel,href[,att1=val1,att2=val2] "
                "(repeat option for multiple links)")
        loc.add_argument('--describedby-link', type=str, action='store',
               help="Add an <rs:md rel=\"describedby\" link to "
                "a description of the feed at the URI given")
        loc.add_argument('--sourcedescription-link', '--source-description-link',
               type=str, action='store',
               help="For a Capability List add a <rs:md rel=\"up\" link to the"
                "Source Description document at the URI given, else ignored")
        loc.add_argument('--capabilitylist-link', '--capability-list-link',
               type=str, action='store',
               help="For all documents except a Capability List or a "
                "Source Description, add an <rs:md rel=\"up\" link "
                "to the Capability List at the URI given")
        loc.add_argument('--reference', type=str, action='store',
               help="Reference sitemap name for --changelist calculation")
        loc.add_argument('--newreference', type=str, action='store',
               help="Updated reference sitemap name for --changelist calculation")
        loc.add_argument('map', metavar='MAP', nargs='+', help='A list of uri=path mappings. If only one argument is passed, do this. If more than one is passed, etc.')
        loc.add_argument('--outfile', type=str, action='store',
            help="write output to specified file rather than STDOUT or default")

        rem = subparsers.add_parser('synchronize', help='Read ResourceSync documents from a remote source, and perform some action to the local disk based on the selected mode.', description='The remote source is specified in a set of uri=path mappings and potentially also using an explicit --sitemap location. The default mode is --baseline. See also: resync-explorer for an interactive client.')

        rem_mode = rem.add_mutually_exclusive_group()
        rem_mode.add_argument('--baseline', '-b', action='store_true', help='Perform a baseline synchronization of resources using a source\'s ResourceList capability. Writes to the local disk.')
        rem_mode.add_argument('--incremental', '--inc', '-i', action='store_true', help='Perform an incremental synchronization of resources using a source\'s ChangeList capability. Uses either timestamp recorded from last baseline or incremental sync for this source, or explicit --from parameter, to determine the earlier update timestamp to act on.')
        rem_mode.add_argument('--audit', '-a', action='store_true',
               help="Audit the synchronization state of the local disk with respect to a remote source.")
        rem_mode.add_argument('--parse', '-p', action='store_true',
               help="Parse a remote sitemap/sitemapindex (from mapping or explicit --sitemap) and show summary information including document type and number of entries.")
        rem.add_argument('--noauth', action='store_true',
               help="Disable all checking of URLs to ensure that the ResourceSync "
                "documents refer only to resources on the same server or sub-domains. "
                "Use with care.")
        rem.add_argument('--strictauth', action='store_true',
               help="Use more strict checking of URLs to ensure that the ResourceSync "
                "documents refer only to resources on the same server or sub-domains, "
                "and on the same server to sub-paths. This is the authority model "
                "of Sitemaps but there are legitimate uses where these rules would "
                "not be followed.")
        rem.add_argument('--sitemap', type=str, action='store',
               help="Explicitly set sitemap name, overriding default sitemap.xml "
                "appended to first source URI specified in the mappings")
        rem.add_argument('--changelist-uri', '--change-list-uri', type=str, action='store',
               help="Explicitly set the changelist URI that will be use in --inc mode, "
                "overrides process of getting this from the sitemap")
        rem.add_argument('--from', type=str, action='store', dest='from_datetime', metavar="DATETIME",
               help="Explicit datetime value used to filter updates in change list for "
                "--incremental sync")
        rem.add_argument('--delete', action='store_true',
               help="Allow local files to be deleted.")
        rem.add_argument('--dryrun', '-n', action='store_true',
               help="Don't update local resources, say what would be done")

        # Specification of map between remote URI and local file paths, and remote sitemap
        rem.add_argument('map', metavar='MAPPING', nargs='+', help='''If there are exactly two entries then these may be the source base URI and the destination base path. Neither may contain an equals (=) sign. For any number of mapping stings interpret each as a mapping URI=path. These are in the order they will be tried.  And if use_default_path is True then a third: If there is exactly one entry and it does not contain an equals (=) sign then a safe local path is created based on the source base URI. In the case that the source base URI is a local path already then an indentity mapping is used.If only one argument is passed, do this. If more than one is passed, etc.''')



    else:
        # argparse
        pass

    (args, map) = p.parse_args()


    # Implement exclusive arguments and default --baseline (support for exclusive
    # groups in argparse is incomplete is python2.6)
    if (not args.baseline and not args.incremental and not args.audit and
            not args.parse and not args.resourcelist and not args.changelist and
            not args.capabilitylist and not args.sourcedescription and
            not args.resourcedump and not args.changedump):
        if (len(map) == 0):
            p.error("No arguments specified (use -h for help)")
            return
        else:
            args.baseline = True
    elif (count_true_args(args.baseline, args.incremental, args.audit, args.parse,
                          args.resourcelist, args.changelist, args.capabilitylist,
                          args.sourcedescription, args.resourcedump, args.changedump) > 1):
        p.error("Only one of --baseline, --incremental, --audit, --parse, --resourcelist, --changelist, --capabilitylist, --sourcedescription, --resourcedump, --changedump modes allowed")

    # Configure logging module and create logger instance
    init_logging(to_file=args.logger, logfile=args.logfile, default_logfile=DEFAULT_LOGFILE,
                 verbose=args.verbose, eval_mode=args.eval)

    if (args.checksum):
        args.hash.append('md5')
    c = Client(hashes=args.hash,
               verbose=args.verbose,
               dryrun=args.dryrun)

    try:
        if (map):
            # Mappings apply to (almost) everything
            c.set_mappings(map)
        if (args.sitemap):
            c.sitemap_name = args.sitemap
        if (args.warc):
            if not args.resourcedump or not args.changedump:
                p.error('--warc may only be used with a dump')
            c.dump_format = 'warc'
        if (args.exclude):
            c.exclude_patterns = args.exclude
        if (args.multifile):
            c.allow_multifile = not args.multifile
        if (args.noauth):
            c.noauth = args.noauth
        if (args.strictauth):
            c.strictauth = args.strictauth
        if (args.max_sitemap_entries):
            c.max_sitemap_entries = args.max_sitemap_entries
        if (args.ignore_failures):
            c.ignore_failures = args.ignore_failures

        # Links apply to anything that writes sitemaps
        links = parse_links(args.link)
        # Add specific links is appropriate cases
        if (args.capabilitylist_link and
                not args.capabilitylist and
                not args.sourcedescription):
            # rel="up" to Capability List in all but Capability List
            # and Source Description
            links.insert(0, {'rel': 'up', 'href': args.capabilitylist_link})
        if (args.sourcedescription_link and args.capabilitylist):
            # rel="up" to Source Description from Capability List
            links.insert(0, {'rel': 'up', 'href': args.sourcedescription_link})
        if (args.describedby_link):
            links.insert(0, {'rel': 'describedby',
                             'href': args.describedby_link})

        # Finally, do something...
        if (args.baseline or args.audit):
            c.baseline_or_audit(allow_deletion=args.delete,
                                audit_only=args.audit)
        elif (args.incremental):
            c.incremental(allow_deletion=args.delete,
                          change_list_uri=args.changelist_uri,
                          from_datetime=args.from_datetime)
        elif (args.parse):
            c.parse_document()
        elif (args.resourcelist or args.resourcedump):
            c.write_resource_list(paths=args.paths,
                                  outfile=args.outfile,
                                  links=links,
                                  dump=args.resourcedump)
        elif (args.changelist or args.changedump):
            if (not args.reference and not args.empty):
                p.error(
                    "Must supply --reference sitemap for --changelist, or --empty")
            c.write_change_list(ref_sitemap=args.reference,
                                newref_sitemap=(args.newreference if (
                                    args.newreference) else None),
                                empty=args.empty,
                                paths=args.paths,
                                outfile=args.outfile,
                                links=links,
                                dump=args.changedump)
        elif (args.capabilitylist):
            c.write_capability_list(
                capabilities=parse_capabilities(args.capabilitylist),
                outfile=args.outfile,
                links=links)
        elif (args.sourcedescription):
            c.write_source_description(
                capability_lists=parse_capability_lists(
                    args.sourcedescription),
                outfile=args.outfile,
                links=links)
        else:
            p.error("Unknown mode requested")
    # Any problem we expect will come as a ClientFatalError, anything else
    # is... an exception ;-)
    except ClientFatalError as e:
        sys.stderr.write("\nFatalError: " + str(e) + "\n")

if __name__ == '__main__':
    main()
